# -*- coding: utf-8 -*-
import numpy
import nibabel
import dipy
import dipy.direction
import dipy.reconst.csdeconv

from core.toad.generictask import GenericTask
from lib.images import Images
from lib.mriutil import getlmax

__author__ = "Mathieu Desrosiers"
__copyright__ = "Copyright (C) 2014, TOAD"
__credits__ = ["Mathieu Desrosiers"]


class HardiDipy(GenericTask):


    def __init__(self, subject):
        GenericTask.__init__(self, subject, 'upsampling', 'registration', 'masking', 'qa')
        self.__dwiData = None
        self.__csdModel = None
        self.__csdPeaks = None


    def implement(self):

        dwi = self.getUpsamplingImage('dwi', 'upsample')
        mask = self.getRegistrationImage('mask', 'resample')

        #Look first if there is eddy b encoding files produces
        bValsFile = self.getUpsamplingImage('grad', None, 'bvals')
        bVecsFile = self.getUpsamplingImage('grad', None, 'bvecs')
        self.set('lmax', getlmax(dwi))
        self.__produceMetrics(dwi, bValsFile, bVecsFile, mask)


    def __produceMetrics(self, source, bValsFile, bVecsFile, mask):
        self.info("Starting fODF creation from dipy on {}".format(source))

        dwiImage = nibabel.load(source)
        maskImage = nibabel.load(mask)

        dwiData  = dwiImage.get_data()
        maskData = maskImage.get_data()
        dwiData = dipy.segment.mask.applymask(dwiData, maskData)

        gradientTable = dipy.core.gradients.gradient_table(numpy.loadtxt(bValsFile), numpy.loadtxt(bVecsFile))
        self.info('WARNING: We need to flip the x direction due to MRtrix new way to extract bvecs')
        gradientTable.gradients = gradientTable.gradients * numpy.array([-1,1,1])

        sphere = dipy.data.get_sphere(self.get("triangulated_spheres"))

        response, ratio = dipy.reconst.csdeconv.auto_response(gradientTable, dwiData, roi_radius=10, fa_thr=0.7)
        csdModel = dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel(gradientTable, response)
        self.info('Start fODF computation')

        csdPeaks = dipy.direction.peaks_from_model(
            model=csdModel,
            data=dwiData,
            sphere=sphere,
            relative_peak_threshold=.5,
            min_separation_angle=25,
            mask=maskData,
            return_sh=True,
            return_odf=False,
            normalize_peaks=True,
            npeaks=5,
            parallel=True,
            nbr_processes=int(self.getNTreads()),
            )

        #CSD
        target = self.buildName(source, 'csd')
        csdCoeff = csdPeaks.shm_coeff
        csdCoeffImage = nibabel.Nifti1Image(csdCoeff.astype(numpy.double), dwiImage.get_affine())
        nibabel.save(csdCoeffImage, target)


        #GFA
        target = self.buildName(source,'gfa')
        gfa = csdPeaks.gfa
        gfa[numpy.isnan(gfa)] = 0
        csdCoeffImage = nibabel.Nifti1Image(gfa.astype(numpy.float32), dwiImage.get_affine())
        nibabel.save(csdCoeffImage, target)


        #NUFO
        target = self.buildName(source, 'nufo')
        nuDirs = gfa
        for x in range(gfa.shape[0]):
            for y in range(gfa.shape[1]):
                for z in range(gfa.shape[2]):
                    nuDirs[x,y,z] = numpy.count_nonzero(csdPeaks.peak_dirs[x,y,z]!=0)/3

        numDirsImage = nibabel.Nifti1Image(nuDirs.astype(numpy.float32), dwiImage.get_affine())
        nibabel.save(numDirsImage, target)

        #Data for qa
        self.__dwiData = dwiData
        self.__csdModel = csdModel
        self.__csdPeaks = csdPeaks


    def isIgnore(self):
        return self.get("ignore")


    def meetRequirement(self):
        return Images((self.getUpsamplingImage('dwi', 'upsample'), "upsampled diffusion"),
                  (self.getUpsamplingImage('grad', None, 'bvals'), "gradient value bvals encoding file"),
                  (self.getUpsamplingImage('grad', None, 'bvecs'), "gradient vector bvecs encoding file"),
                  (self.getRegistrationImage('mask', 'resample'), 'brain  mask'))


    def isDirty(self):
        return Images((self.getImage('dwi', 'csd'), "constrained spherical deconvolution"),
                  (self.getImage('dwi', 'gfa'), "generalised Fractional Anisotropy"),
                  (self.getImage('dwi', 'nufo'), 'nufo'))


    def qaSupplier(self):
        """Create and supply images for the report generated by qa task

        """
        qaImages = Images()
        softwareName = 'dipy'

        #Get images
        dwi = self.getUpsamplingImage('dwi', 'upsample')
        cc = self.getMaskingImage('aparc_aseg', ['253','mask'])
        mask = self.getRegistrationImage('mask', 'resample')

        #Produce hardi odfs image
        data = {'dwiData':self.__dwiData, 'csdModel':self.__csdModel}
        odfsQa = self.plotReconstruction(data, mask, cc, 'hardi_odf', dwi)
        qaImages.append((
            odfsQa, 'Coronal slice of hardi CSD ODFs in the Corpus Callosum'))

        #Produce hardi peaks image
        peaksQa = self.plotReconstruction(
                self.__csdPeaks, mask, cc, 'hardi_peak', dwi)
        qaImages.append((
            peaksQa, "Coronal slice of hardi CSD Peaks in the Corpus Callosum"))

        #Build qa images
        tags = (
            ('gfa', 1.5, 'Generalised Fractional Anisotropy'),
            ('nufo', 5, 'nufo'),
            )

        for postfix, vmax, description in tags:
            image = self.getImage('dwi', postfix)
            if image:
                imageQa = self.plot3dVolume(
                        image, fov=mask, vmax=vmax,
                        colorbar=True, postfix=softwareName)
                qaImages.append((imageQa, description))

        return qaImages
